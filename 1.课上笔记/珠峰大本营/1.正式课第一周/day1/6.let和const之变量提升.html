<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
    * let和const
    * let 变量
    * 1. 声明的变量没有变量提升
    * 2. let 声明的变量不可以重复声明
    * 3. let 声明的变量不会给全局对象window增加属性
    * const 常量
    * 1. let 声明变量具有的特性，const都具有
    * 2. const 声明的常量，如果值是基本数据类型，那么不可以进行修改，如果值是引用数据类型，我可以操作引用地址，不可以替换引用地址。
    * 3. const 声明的常量必须赋值，不赋值报错
    *
    * 注意：let 虽然不会进行变量提升，但是会检查当前作用域下是否有重复声明的变量
    * */

  /*  console.log(a);// a is not defined
    let a = 1 ;*/

    /*let a = 1 ;
    let a = 2 ; // 'a' has already been declared*/

    /*a = 1 ;
    console.log(window.a) ; // 1
    let b = 2;
    console.log(window.b) // undefined*/

    /*const a = 1 ;
    a = 2 ;*/

    /*const a = [1];
    //a[1] ='a';
    a[1] = [1]
    console.log(a);*/

    /*let a ;
    const b;*/

    /*console.log(a);
    let a = 1 ;
    function a() {

    }
    console.log(a);*/

    var a =2;
    if('a' in window) {
        //console.log(a);// 暂时性死区 ，在块级作用域下，不能提前拿到let声明的变量，我们叫这种现象叫做暂时性死区
        let a =1;
    }
    console.log(a);

    for(let i =0;i<3;i++){
        setTimeout(function () {
            console.log(i);// 3X3 0 1 2
        },1000)
    }
    // {
    //    let i = 0
    //     setTimeout(function () {
    //         console.log(i);// 3X3 0 1 2
    //     },1000)
    // }
    // {
    //     let i =1
    //     setTimeout(function () {
    //         console.log(i);// 3X3 0 1 2
    //     },1000)
    // }
    // {
    //     let i = 2
    //     setTimeout(function () {
    //         console.log(i);// 3X3 0 1 2
    //     },1000)
    // }
</script>